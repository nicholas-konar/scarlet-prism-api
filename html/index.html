<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>OpenAI Stream Test</title>
        <style>
            body {
                font-family: sans-serif;
                padding: 2em;
            }
            textarea {
                width: 100%;
                height: 4em;
            }
            pre {
                white-space: pre-wrap;
                border: 1px solid #ccc;
                padding: 1em;
                height: 300px;
                overflow-y: auto;
                margin-top: 1em;
            }
            button {
                margin-top: 0.5em;
                padding: 0.5em 1em;
            }
        </style>
    </head>
    <body>
        <h1>OpenAI Stream Test</h1>

        <label for="prompt">Prompt:</label>
        <textarea id="prompt" placeholder="Type somethingâ€¦"></textarea>
        <br />
        <button id="send">Send</button>

        <pre id="output"></pre>

        <script>
            async function streamChat(prompt) {
                // clear previous output
                const out = document.getElementById("output")
                out.textContent = ""

                const res = await fetch("http://localhost:3000/ai/chat", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        prompt: prompt,
                        conversationId: "test123456",
                    }),
                })

                if (!res.ok) {
                    out.textContent =
                        "Error: " + res.status + " " + res.statusText
                    return
                }

                const reader = res.body.getReader()
                const decoder = new TextDecoder()
                let done = false
                let buffer = ""

                while (!done) {
                    const { value, done: streamDone } = await reader.read()
                    done = streamDone
                    if (value) {
                        buffer += decoder.decode(value, { stream: true })

                        // split on SSE delimiter
                        const parts = buffer.split("\n\n")
                        buffer = parts.pop() // last part is possibly incomplete

                        for (const part of parts) {
                            // SSE format is "data: <payload>"
                            if (part.trim() === "data: [DONE]") {
                                out.textContent += "\n\n<< stream closed >>"
                                return
                            }
                            if (part.startsWith("data: ")) {
                                try {
                                    const token = JSON.parse(
                                        part.replace(/^data: /, ""),
                                    )
                                    out.textContent += token
                                    // scroll as new tokens arrive
                                    out.scrollTop = out.scrollHeight
                                } catch (e) {
                                    console.error("Failed to parse", part, e)
                                }
                            }
                        }
                    }
                }
            }

            document.getElementById("send").addEventListener("click", () => {
                const prompt = document.getElementById("prompt").value.trim()
                if (prompt) {
                    streamChat(prompt)
                }
            })
        </script>
    </body>
</html>
